<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スレッド詳細</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="loading-spinner" style="display:none;">
        <div class="spinner"></div>
    </div>

    <a href="index.html" id="home-button">
        <img src="src/home.png" alt="ホーム" id="home-icon">
    </a>

    <a id="x-share-button">
        <img src="src/x.png" alt="x" id="x-icon">
    </a>

    <div id="thread-container"></div>

    <div id="comment-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>コメントを追加</h2>
            <div id="thread_address"></div>
            <textarea id="comment-message" placeholder="コメントを入力"></textarea>
            <input type="number" id="xym-amount" placeholder="送金するXYMを入力">
            <button id="submit-comment" class="create-thread">送信</button>
        </div>
    </div>
    <button id="comment-button" class="reply-comment">コメントする</button>

    <div id="thread-list"></div>

    <script type="text/javascript" src="https://xembook.github.io/nem2-browserify/symbol-sdk-pack-2.0.5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <!-- <script src="script.js"></script> -->

    <script>
        const sym = require('/node_modules/symbol-sdk');

        // URLからスレッドID（トランザクションハッシュ）を取得
        const urlParams = new URLSearchParams(window.location.search);
        const transactionHash = urlParams.get('id');
        const shortTag = `#${transactionHash.substring(0, 5)}`;

        //Repository setup to connect to the node
        const NODE = 'https://symbol-mikun.net:3001';
        const repo = new sym.RepositoryFactoryHttp(NODE);
        const txRepo = repo.createTransactionRepository();
        const epochAdjustment = 1615853185;

        // トランザクションの詳細を取得してメッセージを表示
        txRepo.getTransaction(transactionHash, sym.TransactionGroup.Confirmed).subscribe(tx => {
            let message = tx.message.payload;  // トランザクションのメッセージを取得
            const thread_owner = tx.signer.address.address;

            console.log(message);

            document.getElementById('thread_address').innerHTML = `<span style="font-size: 13px;">To:<br>${thread_owner}</span>`; // コメントモーダルにアドレス表示

            let thread_title = message.replace(/^#\w{5}\s/, '');

            document.getElementById('thread-container').innerHTML = `<div style="text-align: center">&nbsp;&nbsp;
            <img src="${getRandomImage(tx.signer.publicKey)}" alt="Avatar" class="avatar"></div>
            <h3>${thread_title}</h3>`;

            document.getElementById('submit-comment').addEventListener('click', function () {
                const message = document.getElementById('comment-message').value;
                const amount = document.getElementById('xym-amount').value;

                if (!message || amount < 0.000001) {
                    Swal.fire('コメントと送金するXYMを確認してください');
                    return;
                }

                if (byteLengthUTF8(message) > 1023) {
                    Swal.fire(`メッセージのサイズが${bytelength(message)}バイトです!!          
                              1023バイト 以下にしてください。`);
                    return;
                }

                // コメントをSymbolブロックチェーンに送信する処理をここに追加
                sendCommentTransaction(thread_owner, message, amount, shortTag);

                // モーダルを閉じる
                document.getElementById('comment-modal').style.display = 'none';
            });

            // ページロード時にスレッドを表示する
            window.addEventListener('load', displayThreads(thread_owner, shortTag));

        }, err => {
            console.error('トランザクション取得エラー:', err);
            document.getElementById('thread-container').innerHTML = `<h2>メッセージの取得に失敗しました</h2>`;
        });

        document.addEventListener('DOMContentLoaded', function () {
            // モーダルを開く
            document.getElementById('comment-button').addEventListener('click', function () {
                document.getElementById('comment-modal').style.display = 'flex';
            });

            // モーダルを閉じる
            document.querySelector('.close').addEventListener('click', function () {
                document.getElementById('comment-modal').style.display = 'none';
            });

            // モーダル外をクリックした場合も閉じる
            window.addEventListener('click', function (event) {
                if (event.target == document.getElementById('comment-modal')) {
                    document.getElementById('comment-modal').style.display = 'none';
                }
            });
        });

        function sendCommentTransaction(thread_owner, message, amount, shortTag) {
            // const shortTag = generateShortTag(transactionHash);  // 5桁のタグを生成
            const taggedMessage = `${shortTag} ${message}`;  // タグをメッセージの先頭に追加

            console.log("Message=", taggedMessage);
            const recipientAddress = sym.Address.createFromRawAddress(thread_owner);
            const plainMessage = sym.PlainMessage.create(taggedMessage);

            const mosaic = new sym.Mosaic(
                new sym.MosaicId("6BED913FA20223F8"),
                sym.UInt64.fromUint(amount * Math.pow(10, 6))
            );

            const tx = sym.TransferTransaction.create(
                sym.Deadline.create(epochAdjustment),
                recipientAddress,
                [mosaic],
                plainMessage,
                sym.NetworkType.MAIN_NET
            ).setMaxFee(100);

            if (window.innerWidth <= 768) {  // ウィンドウサイズで aLice / SSS を切り替える。
                const transactionPayload = tx.serialize();
                const aliceUrl = `alice://sign?data=${transactionPayload}&type=request_sign_transaction&node=${sym.Convert.utf8ToHex(NODE)}&method=announce`;
                window.location.href = aliceUrl;
            } else {
                window.SSS.setTransaction(tx);
                window.SSS.requestSign().then(signedTx => {   // SSSを用いた署名をユーザーに要求
                    console.log('signedTx', signedTx);
                    txRepo.announce(signedTx).subscribe(() => {
                        Swal.fire({
                            title: 'Success!',
                            text: 'アナウンスが送信されました！',
                            icon: 'success',
                            confirmButtonText: 'OK'
                        });
                    });
                })
            }
        }


        function displayThreads(address, shortTag) {
            document.getElementById('loading-spinner').style.display = 'block'; // スピナーを表示
            const recipientAddress = sym.Address.createFromRawAddress(address);
            let pageNumber = 1;
            let hasComments = false;  // コメントの有無を確認するフラグ

            const threadContainer = document.getElementById('thread-list');
            threadContainer.innerHTML = ''; // コンテナをクリア

            function fetchTransactions(pageNumber) {
                txRepo.search({
                    group: sym.TransactionGroup.Confirmed,
                    address: recipientAddress,
                    pageSize: 100, // 1ページあたりの最大取得数
                    pageNumber: pageNumber, // 現在のページ
                    order: sym.Order.Desc,
                }).subscribe(threads => {
                    // トランザクションがあるかどうかを確認
                    if (threads.data.length === 0) {
                        document.getElementById('loading-spinner').style.display = 'none'; // スピナーを非表示
                        if (!hasComments) {
                            // コメントがない場合の表示処理
                            const threadElement = document.createElement('div');
                            threadElement.className = 'thread-item';
                            threadElement.innerHTML = `
                        <div class="thread-message" style="font-size: 20px;">
                            コメントはまだありません
                        </div>
                    `;
                            threadContainer.appendChild(threadElement);
                        }
                        return; // データがない場合は終了
                    }

                    threads.data.forEach(tx => {
                        if (tx.message && tx.message.payload) {
                            const message = tx.message.payload;
                            if (message.startsWith(shortTag)) {  // 識別タグでフィルタリング
                                hasComments = true;  // コメントがあったことを記録
                                const commentContent = message.replace(`${shortTag} `, '');  // タグを除去して表示
                                const threadElement = document.createElement('div');
                                threadElement.className = 'thread-item';

                                const timestamp = epochAdjustment + (parseInt(tx.transactionInfo.timestamp.toHex(), 16) / 1000);
                                const date = new Date(timestamp * 1000);

                                const yyyy = `${date.getFullYear()}`;
                                const MM = `0${date.getMonth() + 1}`.slice(-2);
                                const dd = `0${date.getDate()}`.slice(-2);
                                const HH = `0${date.getHours()}`.slice(-2);
                                const mm = `0${date.getMinutes()}`.slice(-2);
                                const ss = `0${date.getSeconds()}`.slice(-2);

                                const ymdhms = `${yyyy}-${MM}-${dd} ${HH}:${mm}:${ss}`;

                                const xymAmount = tx.mosaics[0].amount.compact() / Math.pow(10, 6);
                                const fontSize = Math.min(10 + xymAmount * 10, 50);

                                threadElement.innerHTML = `
                            <div class="thread-header">
                                <img src="${getRandomImage(tx.signer.publicKey)}" alt="Avatar" class="avatar">
                                <div class="thread-info">
                                    <div class="thread-date">${ymdhms}</div>
                                    <div class="thread-amount">${xymAmount} XYM</div>
                                </div>
                            </div>
                            <div class="thread-message" style="font-size: ${fontSize}px;">
                                ${commentContent}
                            </div>
                            <button class="open-thread-button" data-hash="${tx.transactionInfo.hash}">スレッドを開く</button>
                        `;

                                threadContainer.appendChild(threadElement);

                                document.querySelectorAll('.open-thread-button').forEach(button => {
                                    button.addEventListener('click', function () {
                                        const transactionHash = button.getAttribute('data-hash'); // トランザクションハッシュを取得
                                        window.location.href = `thread.html?id=${transactionHash}`;  // 新しいページに遷移
                                    });
                                });
                            }
                        }
                    });

                    // 次のページのトランザクションを取得
                    pageNumber++;
                    fetchTransactions(pageNumber);
                }, err => {
                    console.error('トランザクション取得エラー:', err);
                    document.getElementById('loading-spinner').style.display = 'none'; // エラー時もスピナーを非表示
                });
            }

            // 最初のページの取得を開始
            fetchTransactions(pageNumber);
        }

        function getRandomImage(publicKey) {
            const hash = CryptoJS.SHA256(publicKey).toString();
            const index = parseInt(hash.slice(0, 8), 16) % 16 + 1; // ランダムに1-16の範囲の数値を生成
            return `https://ventus-wallet.net/thread/avatar/${index}.png`; // ランダムな画像URLを返す
        }

        document.getElementById('x-share-button').addEventListener('click', function () {
            const pageUrl = window.location.href;
            const x_Url = `https://x.com/intent/post?url=${encodeURIComponent(pageUrl)}`;
            window.open(x_Url);
        });


        /*   function bytelength(s) {
               return encodeURI(s).replace(/%../g, "*").length;
           }*/

        function byteLengthUTF8(s) {
            return new TextEncoder().encode(s).length;
        }

    </script>
</body>

</html>